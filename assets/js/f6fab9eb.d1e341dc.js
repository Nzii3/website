"use strict";(self.webpackChunkguide_pycord_dev=self.webpackChunkguide_pycord_dev||[]).push([[628],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return f}});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=o.createContext({}),u=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=u(e.components);return o.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,l=a(e,["components","mdxType","originalType","parentName"]),m=u(n),f=i,p=m["".concat(c,".").concat(f)]||m[f]||d[f]||r;return n?o.createElement(p,s(s({ref:t},l),{},{components:n})):o.createElement(p,s({ref:t},l))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=m;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a.mdxType="string"==typeof e?e:i,s[1]=a;for(var u=2;u<r;u++)s[u]=n[u];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4567:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return a},metadata:function(){return u},toc:function(){return d}});var o=n(7462),i=n(3366),r=(n(7294),n(3905)),s=["components"],a={title:"Buttons",description:"Discord Buttons in Pycord"},c=void 0,u={unversionedId:"pycord-examples/discord-ui/buttons",id:"pycord-examples/discord-ui/buttons",title:"Buttons",description:"Discord Buttons in Pycord",source:"@site/docs/pycord-examples/discord-ui/buttons.md",sourceDirName:"pycord-examples/discord-ui",slug:"/pycord-examples/discord-ui/buttons",permalink:"/pycord-examples/discord-ui/buttons",draft:!1,tags:[],version:"current",frontMatter:{title:"Buttons",description:"Discord Buttons in Pycord"},sidebar:"defaultSidebar",previous:{title:"Discord UI",permalink:"/category/discord-ui"},next:{title:"Subclassing",permalink:"/pycord-examples/subclassing"}},l={},d=[],m={toc:d};function f(e){var t=e.components,n=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"I would COMPLETELY recommend subclassing EVERYTHING from the \"message component family\" (buttons, selects, context menus, modals, etc). The reason for this is because you can handle the callback easier, use the views persistently (check main.py for more info), you can also do something with else the 'interaction_check' event (to see if the author is the author of the message). With the interaction_check, ill show you my way to compare user objects to see who's the author or not while not having to pass in 'ctx' as you might not have access to it in every situation (e.g. events). While subclassing, you can also handle the 'on_timeout' event, this will occur when the view times out ",(0,r.kt)("inlineCode",{parentName:"p"},"super().__init__(timeout=float)"),". You won't find examples of non-subclassed views as it's not recommended by anyone, it's easier to subclass."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Credit: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Pycord-Development/pycord/blob/master/examples/views/confirm.py"},"https://github.com/Pycord-Development/pycord/blob/master/examples/views/confirm.py"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'import discord\nfrom discord.ext import commands\n\nclass Confirm(discord.ui.View):\n  def __init__(self, author: discord.User):\n    self.author = author # this is what you will set when defining the view in your other code: this user object that is the person that invoked the command or event and that person will be the only one confirming/canceling\n    super().__init__(timeout=30) # you can edit this to whatever you want in SECONDS\n    self.value = None\n    # AND THEN YOU CAN DO:\n    # view = Confirm(author=myauthorobject)\n    # await view.wait()\n    # if view.value == "Yes":\n    # (do something)\n    # if view.value == "No":\n    # (do something)\n\n    async def on_timeout(self): # if you don\'t want this, remove it. you will need to do `view.message = myMessageObject` after doing view = Confirm(author=myauthorobject)\n      for child in self.children:\n        child.disabled = True # making all the components on the message disabled\n      await self.message.edit(content="Timeout exceeded!", view=self) # if you want, you can pass in \'embed=None\' to make sure that the message edits itself with no embed.\n\n    async def interaction_check(self, interaction: discord.Interaction) -> bool: # you have to retuen this as a bool object or it wont work\n      if interaction.user != self.author: # accessing the discord.User object we set earlier\n        await interaction.response.send_message("This is not for you.", ephemeral=True)\n        return False\n      else:\n        return True\n\n    @discord.ui.button(label="Yes", style=discord.ButtonStyle.green)\n    async def confirm(self, button, interaction):\n      for child in self.children:\n        child.disabled = True\n      self.value = "Yes"\n      self.stop()\n\n    @discord.ui.button(label="No", style=discord.ButtonStyle.red)\n    async def cancel(self, button, interaction):\n      for child in self.children:\n        child.disabled = True\n      self.value = "No"\n      self.stop()\n    \n\n# somewhere else\n\nclass MyCog(commands.Cog):\n  def __init__(self, bot):\n    self.bot = bot\n  \n  @commands.command()\n  async def confirm(self, ctx):\n    view = Confirm(author=ctx.author) # defining view and setting author\n    message = await ctx.send("Would you like to confirm?", view=view)\n    view.message = message\n    await view.wait()\n    if view.value == "Yes":\n      await view.message.edit(content=f"You confirmed with {view.value}!", view=view) # we edit view to view because the buttons have been disabled in the class when the user clicks a button\n    if view.value == "No":\n      await view.message.edit(content=f"You canceled with {view.value}!", view=view)\n\ndef setup(bot):\n  bot.add_cog(MyCog(bot))\n\n')))}f.isMDXComponent=!0}}]);